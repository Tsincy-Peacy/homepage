# 汇编语言第一讲

## 第一章：基础知识

### 为什么要设计汇编语言，而不是用机器码编程？

机器码就是一堆0/1串，极难辨识，且发生错误人眼很难找到问题。比如找出这两条指令的不同之处：

`1001001110010010` 和 `1001001100010010`

### 汇编语言的产生

每条指令有特定的作用，比如将寄存器 `BX` 的内容送到 `AX`，可以记为 `mov ax, bx`，一目了然。

### 汇编语言的组成

- 汇编指令：一个汇编指令对应一条机器码。

- 伪指令：一个伪指令是由多条汇编指令组成，这主要是为了便于使用，在执行时先由编译器展开为多条汇编指令。

- 其他符号：+、-、*、/ 等。

### 存储器的作用

CPU 与存储器的关系，类似于大脑与记忆的关系，CPU 负责数据的控制和运算，存储器负责数据的存放和读取。

### 指令和数据

在 16 位 8086 处理器中，指令和数据都是 16 位，那么 CPU 如何区分一段数字是指令还是数据？事实上，如何看待取决于你的处理方式，比如 `1000100111011000` 可以是指令 `mov ax, bx`（指令），也可以是 `89D8H`（数据）。

指令和数据都存放于存储器中。

### 存储单元

对于 16 位的 8086 处理器而言，其地址线为 20 位，对应 $2^{20}$ 个地址（0 ~ $2^{20}-1$），每个地址对应一个存储单元，每个存储单元是一个 8 bit 的字节，即这样的存储器可以存放 $2^{20}$ 个 Byte。

通常使用 B 来代替 Byte，内存换算关系：

1 KB = 1024 B

1 MB = 1024 KB

1 GB = 1024 MB

1 TB = 1024 GB

PS：字是处理器能够处理的最大数据单位，对于 8086，一个字表示两个字节，即 1 W = 2 B。

### 总线

总线分为数据总线、地址总线和控制总线，了解即可，对于汇编语言的学习没有太多影响。CPU、存储器和外界设备通过总线交换数据。

这些设备在物理上是独立的，但对于 CPU 而言，它们只是对应不同的总线地址，例如 `00000` ~ `9FFFF` 对应 RAM，`A0000` ~ `BFFFF` 对应显存，`C0000` ~ `FFFFF` 对应 ROM

## 第二章：寄存器

### 什么是寄存器？

顾名思义，寄存器就是寄存数据的器件，它是 CPU 内部的部件，可以通过指令将数据存放在寄存器中，也可以通过指令读取寄存器中存放的数据。

16 位 8086 处理器的所有寄存器都是 16 位，即一个字。

### 通用寄存器

`AX`、`BX`、`CX`、`DX` 这四个寄存器通常用来存放一般性的数据，被称为通用寄存器。这四个寄存器都可以分为高位寄存器和低位寄存器，如 `AX` 分为 `AH` 和 `AL`。

### 几条汇编指令

`mov ax, 18`：`AX` = 18。

`mov ah, 78`：`AH` = 78（思考和 `AX` 的区别）。

`add ax, 7`：`AX` = `AX` + 7。

`sub bx, [9]`：`BX` = `BX` - `memory[DS:9]`。

`mov ax, bx`：`BX` = `AX`。

`add ax, bx`：`AX` = `AX` + `BX`。

### 8086 CPU 给出物理地址的方法

我们知道，8086 的寄存器是 16 位，而地址总线为 20 位，如何用 16 位的寄存器给出 20 位的地址呢？答案是使用两个寄存器。第一个寄存器给出高 16 位，称为段地址；第二个寄存器给出低 16 位，称为偏移地址，然后将他们相加。

例如，一个寄存器给出高位为 `1230H`，另一个寄存器给出低位为 `00C8H`，由于高位寄存器无法表示后四位，故将其补充为 `12300H`，与低位相加得到 `123C8H`。补充后四位又叫“左移四位”。

由于左移四位又可以写成乘以 16，所以上述方法可以写为：物理地址 = 段地址 x 16 + 偏移地址。

### 什么是段？

段是一片连续的内存，这是一个人为定义，而不是内存本来就是分段的。例如你可以规定 `10000H ~ 100FFH` 为一个段，也可以将 `10000H` ~ `1007FH` 和 `10080H` ~ `100FFH` 定义为两个分段。

8086 有四个段寄存器：`CS`、`DS`、`SS` 和 `ES`。

本次只关心 `CS`。

`CS` 是 Code Segment，`IP` 是 Instruction Pointer，它们指示了读取指令的地址。如果 `CS` 中的内容为 M，`IP` 中的内容为 N，那么 8086 将从 16 x M + N 的内存处读取一条指令并执行。我们将这样的计算形式简写为 `M:N`。

### 如何改变 `CS` 和 `IP`？

很遗憾，我们并不能像使用 `mov` 修改 `AX` 那样来随意修改 `CS` 和 `IP`，8086 禁止用户这样做。但我们可以使用专用的指令来做到一定程度的修改，这里介绍一个最简单的指令：`jmp`。

`jmp segment:offset`：`CS` = segment，`IP` = offset。

`jmp register`：`IP` = register。

例如，`jmp 2AE3:3` 表示 `CS` = 2AE3，`IP` = 3；`jmp ax` 表示 `IP` = `AX`。

思考：以下代码段的执行顺序。

```
初始条件：CS = 2000H，IP = 0000H

10000H: mov ax, 0123H
10003H: mov ax, 0000
10006H: mov bx, ax
10008H: jmp bx
...
20000H: mov ax, 6622H
20003H: jmp 1000:3
20008H: mov cx, ax
```

## 第三章：内存访问

### 大尾端和小尾端

8086 是小尾端的机器。尾端指的是有效数据最低位，大尾端指的是这个最低位存储在高地址，小尾端则是存储在低地址。

例如将 0123H 存储在 8086 的内存中，则按照内存顺序，0 地址处存放 01H，1地址处存放 23H。

### 存取数据

在第二章中我们讲解了 8086 如何使用 `CS` 和 `IP` 读取指令，当需要操作数据时，8086 使用的寄存器是 `DS`，偏移则使用 `[address]`。

下面三条指令将 `10000H`（1000:0）的数据读取到 `AL` 中：

```
mov bx, 1000H
mov ds, bx
mov al, [0]

; 注意，不能直接把立即数（1000H）直接写入 DS，这是硬件问题
```

### 栈

栈就是一个泡腾片的瓶子，放入泡腾片，只能倒着拿出来。在 8086 处理器中，栈每次可以送入一个字，或者弹出一个字。与指令段和数据段类似，栈使用 `SS:SP` 来表示栈的位置，`SS x 16 + SP` 指向最后一次送入的“泡腾片”的位置。栈由地址高位向地址低位生长，例如，`SP` 初始时为 `FFFEH`，送入一个字变为 `FFFCH`，再送入一个字变为 `FFFAH`；此时，弹出一个字变为 `FFFCH`，再弹出一个字变为 `FFFEH`。

示例指令为：

```
mov ax, 0123H ; AX = 0123H
push ax       ; AX 的值送入栈: -> 0123H, SP -= 2
mov bx, 2266H ; BX = 2266H
push bx       ; BX 的值送入栈: -> 2266H, 0123H, SP -= 2
pop cx        ; 弹出 2266H, CX = 2266H, SP += 2
pop dx        ; 弹出 0123H, DX = 0123H, SP += 2
```

## 第四章：第一个程序

创建一个程序的流程：写代码 -> 编译 -> 执行

### 分析下面的汇编代码

```
assume cs:codesg

codesg segment

    mov ax, 0123H
    mov bx, 0456H
    add ax, bx
    add ax, ax

    mov ax, 4c00H
    int 21H

codesg ends

end
```

- `assume 段寄存器:段名`，将某个段名与段寄存器联系起来。

- `段名 segment ... 段名 ends`，定义一个段。

- `end`，表示源代码的结束。

- `mov ax, 4c00H` + `int 21H`，表示代码返回（暂时不需要了解）。

## 第五章：`[BX]` 和 `loop` 指令

在内容开始之前，定义几个约定的符号。

- `(ax)` 表示 `AX` 存放的数据，`(10000H)` 表示内存单元 `[1000:0]` 存放的数据。

- `idata` 表示一个数字，例如 `mov ax, idata`。

### 什么是 `[BX]`？

我们知道 `[0]` 是一个内存单元，它表示 `DS:0`，`[BX]` 同样如此，它表示 `DS:BX`。

以下代码是合法的：

```
mov ax, [bx]
mov al, [bx]
```

### 什么是 loop？

这里给出一段循环代码：

```
assume cs:code

code segment

    mov ax, 2
    mov cx, 11
s:
    add ax, ax
    loop s

    mov ax, 4c00h
    int 21h

code ends

end
```

- `mov cx, 11`：`CX` 是 Counter Register，用来计数，这里表示循环执行 11 次。

- `s:`：s 是一个循环标记，与 `loop s` 配合使用。

- `loop s`：跳转到循环标记 s 处执行。

### `loop` 和 `[bx]` 的联合使用

这里给出一段代码：

```
assume cs:code

code segment

    mov ax, 0ffffh
    mov ds, ax
    mov bx, 0
    mov cx, 12
s:
    mov al, [bx]
    mov ah, 0
    add dx, ax
    inc bx
    loop s

    mov ax, 4c00h
    int 21h

code ends

end
```

- 第一步：将 `DS` 定位到 `FFFF:0`。

- 第二步：设置 `BX` 偏移为 0。

- 第三步：将循环计数器 `CX` 设置为 12。

- 第四步：进入循环，`AX` = `(DS:BX)`，`DX` += `AX`，`BX`++。

- 第五步：退出程序。

### 什么是段前缀？

`mov ax, cs:[bx]`，这里的 `cs:` 就是段前缀。

存取数据默认的段前缀为 `ds:`，显示地修改可以改变指令行为。
